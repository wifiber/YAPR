---------------------------------------------------------------------------------------
-- Title          : Wishbone slave core for SERDES intfce core registers
---------------------------------------------------------------------------------------
-- File           : serdes_intfce_csr.vhd
-- Author         : auto-generated by wbgen2 from serdes_intfce_csr.wb
-- Created        : Thu Jul  2 22:54:21 2015
-- Standard       : VHDL'87
---------------------------------------------------------------------------------------
-- THIS FILE WAS GENERATED BY wbgen2 FROM SOURCE FILE serdes_intfce_csr.wb
-- DO NOT HAND-EDIT UNLESS IT'S ABSOLUTELY NECESSARY!
---------------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity serdes_intfce_csr is
  port (
    rst_n_i                                  : in     std_logic;
    clk_sys_i                                : in     std_logic;
    wb_adr_i                                 : in     std_logic_vector(3 downto 0);
    wb_dat_i                                 : in     std_logic_vector(31 downto 0);
    wb_dat_o                                 : out    std_logic_vector(31 downto 0);
    wb_cyc_i                                 : in     std_logic;
    wb_sel_i                                 : in     std_logic_vector(3 downto 0);
    wb_stb_i                                 : in     std_logic;
    wb_we_i                                  : in     std_logic;
    wb_ack_o                                 : out    std_logic;
    wb_stall_o                               : out    std_logic;
-- Port for BIT field: 'Tx Dis' in reg: 'Control'
    serdes_intfce_ctrl_tx_dis_o              : out    std_logic;
-- Port for BIT field: 'PRBS Ena' in reg: 'Control'
    serdes_intfce_ctrl_prbs_ena_o            : out    std_logic;
-- Port for BIT field: 'Test Write Enable' in reg: 'Control'
    serdes_intfce_ctrl_tst_wr_ena_o          : out    std_logic;
-- Port for MONOSTABLE field: 'PRBS Cnt Rst' in reg: 'Control'
    serdes_intfce_ctrl_cnt_clr_o             : out    std_logic;
-- Port for BIT field: 'Marker Type' in reg: 'Control'
    serdes_intfce_ctrl_mkr_type_o            : out    std_logic;
-- Port for BIT field: 'LED Test' in reg: 'Control'
    serdes_intfce_ctrl_led_test_o            : out    std_logic;
-- Port for MONOSTABLE field: 'Clear Faults' in reg: 'Control'
    serdes_intfce_ctrl_clr_faults_o          : out    std_logic;
-- Port for MONOSTABLE field: 'GTP Reset' in reg: 'Control'
    serdes_intfce_ctrl_gtp_rst_o             : out    std_logic;
-- Port for MONOSTABLE field: 'Rx Reset' in reg: 'Control'
    serdes_intfce_ctrl_rx_rst_o              : out    std_logic;
-- Port for MONOSTABLE field: 'Tx Reset' in reg: 'Control'
    serdes_intfce_ctrl_tx_rst_o              : out    std_logic;
-- Port for MONOSTABLE field: 'CDR Reset' in reg: 'Control'
    serdes_intfce_ctrl_cdr_rst_o             : out    std_logic;
-- Port for MONOSTABLE field: 'Align Rx' in reg: 'Control'
    serdes_intfce_ctrl_align_o               : out    std_logic;
-- Port for MONOSTABLE field: 'Rx Buf Reset' in reg: 'Control'
    serdes_intfce_ctrl_rx_buf_rst_o          : out    std_logic;
-- Port for BIT field: 'SFP LOS' in reg: 'Status'
    serdes_intfce_sta_sfp_los_i              : in     std_logic;
-- Port for BIT field: 'SFP PRSNT' in reg: 'Status'
    serdes_intfce_sta_sfp_prsnt_i            : in     std_logic;
-- Port for BIT field: 'FMC PRSNT' in reg: 'Status'
    serdes_intfce_sta_fmc_prsnt_i            : in     std_logic;
-- Port for std_logic_vector field: 'Rx Buf Status' in reg: 'Status'
    serdes_intfce_sta_rx_stat_i              : in     std_logic_vector(2 downto 0);
-- Port for std_logic_vector field: 'Rx LOS' in reg: 'Status'
    serdes_intfce_sta_rx_los_i               : in     std_logic_vector(1 downto 0);
-- Port for std_logic_vector field: 'Rx Clock Corr Cnt' in reg: 'Status'
    serdes_intfce_sta_rx_clk_corr_i          : in     std_logic_vector(2 downto 0);
-- Port for BIT field: 'Rx Aligned' in reg: 'Status'
    serdes_intfce_sta_aligned_i              : in     std_logic;
-- Port for BIT field: 'FIFO Full' in reg: 'Status'
    serdes_intfce_sta_fifo_full_i            : in     std_logic;
-- Port for std_logic_vector field: 'Count' in reg: 'PRBS Err Cnt'
    serdes_intfce_prbs_err_cnt_i             : in     std_logic_vector(15 downto 0);
-- Port for std_logic_vector field: 'Addr' in reg: 'Test Mem Addr'
    serdes_intfce_test_mem_addr_o            : out    std_logic_vector(12 downto 0);
-- Port for std_logic_vector field: 'Data' in reg: 'Test Mem Data'
    serdes_intfce_test_mem_dat_data_i        : in     std_logic_vector(15 downto 0);
-- Port for std_logic_vector field: 'Data Is K' in reg: 'Test Mem Data'
    serdes_intfce_test_mem_dat_isk_i         : in     std_logic_vector(1 downto 0);
-- Port for BIT field: 'Marker' in reg: 'Test Mem Data'
    serdes_intfce_test_mem_dat_marker_i      : in     std_logic;
-- Port for std_logic_vector field: 'Rate' in reg: 'Line Rate'
    serdes_intfce_line_rate_i                : in     std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Size' in reg: 'Acq Page Size'
    serdes_intfce_acq_page_size_o            : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Addr' in reg: 'Acq Page Addr'
    serdes_intfce_acq_page_addr_i            : in     std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Addr' in reg: 'Acq Marker Addr'
    serdes_intfce_acq_marker_addr_i          : in     std_logic_vector(31 downto 0)
  );
end serdes_intfce_csr;

architecture syn of serdes_intfce_csr is

signal serdes_intfce_ctrl_tx_dis_int            : std_logic      ;
signal serdes_intfce_ctrl_prbs_ena_int          : std_logic      ;
signal serdes_intfce_ctrl_tst_wr_ena_int        : std_logic      ;
signal serdes_intfce_ctrl_cnt_clr_dly0          : std_logic      ;
signal serdes_intfce_ctrl_cnt_clr_int           : std_logic      ;
signal serdes_intfce_ctrl_mkr_type_int          : std_logic      ;
signal serdes_intfce_ctrl_led_test_int          : std_logic      ;
signal serdes_intfce_ctrl_clr_faults_dly0       : std_logic      ;
signal serdes_intfce_ctrl_clr_faults_int        : std_logic      ;
signal serdes_intfce_ctrl_gtp_rst_dly0          : std_logic      ;
signal serdes_intfce_ctrl_gtp_rst_int           : std_logic      ;
signal serdes_intfce_ctrl_rx_rst_dly0           : std_logic      ;
signal serdes_intfce_ctrl_rx_rst_int            : std_logic      ;
signal serdes_intfce_ctrl_tx_rst_dly0           : std_logic      ;
signal serdes_intfce_ctrl_tx_rst_int            : std_logic      ;
signal serdes_intfce_ctrl_cdr_rst_dly0          : std_logic      ;
signal serdes_intfce_ctrl_cdr_rst_int           : std_logic      ;
signal serdes_intfce_ctrl_align_dly0            : std_logic      ;
signal serdes_intfce_ctrl_align_int             : std_logic      ;
signal serdes_intfce_ctrl_rx_buf_rst_dly0       : std_logic      ;
signal serdes_intfce_ctrl_rx_buf_rst_int        : std_logic      ;
signal serdes_intfce_test_mem_addr_int          : std_logic_vector(12 downto 0);
signal serdes_intfce_acq_page_size_int          : std_logic_vector(31 downto 0);
signal ack_sreg                                 : std_logic_vector(9 downto 0);
signal rddata_reg                               : std_logic_vector(31 downto 0);
signal wrdata_reg                               : std_logic_vector(31 downto 0);
signal bwsel_reg                                : std_logic_vector(3 downto 0);
signal rwaddr_reg                               : std_logic_vector(3 downto 0);
signal ack_in_progress                          : std_logic      ;
signal wr_int                                   : std_logic      ;
signal rd_int                                   : std_logic      ;
signal allones                                  : std_logic_vector(31 downto 0);
signal allzeros                                 : std_logic_vector(31 downto 0);

begin
-- Some internal signals assignments. For (foreseen) compatibility with other bus standards.
  wrdata_reg <= wb_dat_i;
  bwsel_reg <= wb_sel_i;
  rd_int <= wb_cyc_i and (wb_stb_i and (not wb_we_i));
  wr_int <= wb_cyc_i and (wb_stb_i and wb_we_i);
  allones <= (others => '1');
  allzeros <= (others => '0');
-- 
-- Main register bank access process.
  process (clk_sys_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      ack_sreg <= "0000000000";
      ack_in_progress <= '0';
      rddata_reg <= "00000000000000000000000000000000";
      serdes_intfce_ctrl_tx_dis_int <= '0';
      serdes_intfce_ctrl_prbs_ena_int <= '0';
      serdes_intfce_ctrl_tst_wr_ena_int <= '0';
      serdes_intfce_ctrl_cnt_clr_int <= '0';
      serdes_intfce_ctrl_mkr_type_int <= '0';
      serdes_intfce_ctrl_led_test_int <= '0';
      serdes_intfce_ctrl_clr_faults_int <= '0';
      serdes_intfce_ctrl_gtp_rst_int <= '0';
      serdes_intfce_ctrl_rx_rst_int <= '0';
      serdes_intfce_ctrl_tx_rst_int <= '0';
      serdes_intfce_ctrl_cdr_rst_int <= '0';
      serdes_intfce_ctrl_align_int <= '0';
      serdes_intfce_ctrl_rx_buf_rst_int <= '0';
      serdes_intfce_test_mem_addr_int <= "0000000000000";
      serdes_intfce_acq_page_size_int <= "00000000000000000000000000000000";
    elsif rising_edge(clk_sys_i) then
-- advance the ACK generator shift register
      ack_sreg(8 downto 0) <= ack_sreg(9 downto 1);
      ack_sreg(9) <= '0';
      if (ack_in_progress = '1') then
        if (ack_sreg(0) = '1') then
          serdes_intfce_ctrl_cnt_clr_int <= '0';
          serdes_intfce_ctrl_clr_faults_int <= '0';
          serdes_intfce_ctrl_gtp_rst_int <= '0';
          serdes_intfce_ctrl_rx_rst_int <= '0';
          serdes_intfce_ctrl_tx_rst_int <= '0';
          serdes_intfce_ctrl_cdr_rst_int <= '0';
          serdes_intfce_ctrl_align_int <= '0';
          serdes_intfce_ctrl_rx_buf_rst_int <= '0';
          ack_in_progress <= '0';
        else
        end if;
      else
        if ((wb_cyc_i = '1') and (wb_stb_i = '1')) then
          case rwaddr_reg(3 downto 0) is
          when "0000" => 
            if (wb_we_i = '1') then
              serdes_intfce_ctrl_tx_dis_int <= wrdata_reg(0);
              serdes_intfce_ctrl_prbs_ena_int <= wrdata_reg(1);
              serdes_intfce_ctrl_tst_wr_ena_int <= wrdata_reg(2);
              serdes_intfce_ctrl_cnt_clr_int <= wrdata_reg(3);
              serdes_intfce_ctrl_mkr_type_int <= wrdata_reg(4);
              serdes_intfce_ctrl_led_test_int <= wrdata_reg(5);
              serdes_intfce_ctrl_clr_faults_int <= wrdata_reg(6);
              serdes_intfce_ctrl_gtp_rst_int <= wrdata_reg(8);
              serdes_intfce_ctrl_rx_rst_int <= wrdata_reg(9);
              serdes_intfce_ctrl_tx_rst_int <= wrdata_reg(10);
              serdes_intfce_ctrl_cdr_rst_int <= wrdata_reg(11);
              serdes_intfce_ctrl_align_int <= wrdata_reg(12);
              serdes_intfce_ctrl_rx_buf_rst_int <= wrdata_reg(13);
            end if;
            rddata_reg(0) <= serdes_intfce_ctrl_tx_dis_int;
            rddata_reg(1) <= serdes_intfce_ctrl_prbs_ena_int;
            rddata_reg(2) <= serdes_intfce_ctrl_tst_wr_ena_int;
            rddata_reg(3) <= '0';
            rddata_reg(4) <= serdes_intfce_ctrl_mkr_type_int;
            rddata_reg(5) <= serdes_intfce_ctrl_led_test_int;
            rddata_reg(6) <= '0';
            rddata_reg(8) <= '0';
            rddata_reg(9) <= '0';
            rddata_reg(10) <= '0';
            rddata_reg(11) <= '0';
            rddata_reg(12) <= '0';
            rddata_reg(13) <= '0';
            rddata_reg(7) <= 'X';
            rddata_reg(14) <= 'X';
            rddata_reg(15) <= 'X';
            rddata_reg(16) <= 'X';
            rddata_reg(17) <= 'X';
            rddata_reg(18) <= 'X';
            rddata_reg(19) <= 'X';
            rddata_reg(20) <= 'X';
            rddata_reg(21) <= 'X';
            rddata_reg(22) <= 'X';
            rddata_reg(23) <= 'X';
            rddata_reg(24) <= 'X';
            rddata_reg(25) <= 'X';
            rddata_reg(26) <= 'X';
            rddata_reg(27) <= 'X';
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
            ack_sreg(2) <= '1';
            ack_in_progress <= '1';
          when "0001" => 
            if (wb_we_i = '1') then
            end if;
            rddata_reg(0) <= serdes_intfce_sta_sfp_los_i;
            rddata_reg(1) <= serdes_intfce_sta_sfp_prsnt_i;
            rddata_reg(2) <= serdes_intfce_sta_fmc_prsnt_i;
            rddata_reg(10 downto 8) <= serdes_intfce_sta_rx_stat_i;
            rddata_reg(12 downto 11) <= serdes_intfce_sta_rx_los_i;
            rddata_reg(15 downto 13) <= serdes_intfce_sta_rx_clk_corr_i;
            rddata_reg(16) <= serdes_intfce_sta_aligned_i;
            rddata_reg(24) <= serdes_intfce_sta_fifo_full_i;
            rddata_reg(3) <= 'X';
            rddata_reg(4) <= 'X';
            rddata_reg(5) <= 'X';
            rddata_reg(6) <= 'X';
            rddata_reg(7) <= 'X';
            rddata_reg(17) <= 'X';
            rddata_reg(18) <= 'X';
            rddata_reg(19) <= 'X';
            rddata_reg(20) <= 'X';
            rddata_reg(21) <= 'X';
            rddata_reg(22) <= 'X';
            rddata_reg(23) <= 'X';
            rddata_reg(25) <= 'X';
            rddata_reg(26) <= 'X';
            rddata_reg(27) <= 'X';
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "0010" => 
            if (wb_we_i = '1') then
            end if;
            rddata_reg(15 downto 0) <= serdes_intfce_prbs_err_cnt_i;
            rddata_reg(16) <= 'X';
            rddata_reg(17) <= 'X';
            rddata_reg(18) <= 'X';
            rddata_reg(19) <= 'X';
            rddata_reg(20) <= 'X';
            rddata_reg(21) <= 'X';
            rddata_reg(22) <= 'X';
            rddata_reg(23) <= 'X';
            rddata_reg(24) <= 'X';
            rddata_reg(25) <= 'X';
            rddata_reg(26) <= 'X';
            rddata_reg(27) <= 'X';
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "0011" => 
            if (wb_we_i = '1') then
              serdes_intfce_test_mem_addr_int <= wrdata_reg(12 downto 0);
            end if;
            rddata_reg(12 downto 0) <= serdes_intfce_test_mem_addr_int;
            rddata_reg(13) <= 'X';
            rddata_reg(14) <= 'X';
            rddata_reg(15) <= 'X';
            rddata_reg(16) <= 'X';
            rddata_reg(17) <= 'X';
            rddata_reg(18) <= 'X';
            rddata_reg(19) <= 'X';
            rddata_reg(20) <= 'X';
            rddata_reg(21) <= 'X';
            rddata_reg(22) <= 'X';
            rddata_reg(23) <= 'X';
            rddata_reg(24) <= 'X';
            rddata_reg(25) <= 'X';
            rddata_reg(26) <= 'X';
            rddata_reg(27) <= 'X';
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "0100" => 
            if (wb_we_i = '1') then
            end if;
            rddata_reg(15 downto 0) <= serdes_intfce_test_mem_dat_data_i;
            rddata_reg(17 downto 16) <= serdes_intfce_test_mem_dat_isk_i;
            rddata_reg(18) <= serdes_intfce_test_mem_dat_marker_i;
            rddata_reg(19) <= 'X';
            rddata_reg(20) <= 'X';
            rddata_reg(21) <= 'X';
            rddata_reg(22) <= 'X';
            rddata_reg(23) <= 'X';
            rddata_reg(24) <= 'X';
            rddata_reg(25) <= 'X';
            rddata_reg(26) <= 'X';
            rddata_reg(27) <= 'X';
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "0101" => 
            if (wb_we_i = '1') then
            end if;
            rddata_reg(31 downto 0) <= serdes_intfce_line_rate_i;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "0110" => 
            if (wb_we_i = '1') then
              serdes_intfce_acq_page_size_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= serdes_intfce_acq_page_size_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "0111" => 
            if (wb_we_i = '1') then
            end if;
            rddata_reg(31 downto 0) <= serdes_intfce_acq_page_addr_i;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "1000" => 
            if (wb_we_i = '1') then
            end if;
            rddata_reg(31 downto 0) <= serdes_intfce_acq_marker_addr_i;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when others =>
-- prevent the slave from hanging the bus on invalid address
            ack_in_progress <= '1';
            ack_sreg(0) <= '1';
          end case;
        end if;
      end if;
    end if;
  end process;
  
  
-- Drive the data output bus
  wb_dat_o <= rddata_reg;
-- Tx Dis
  serdes_intfce_ctrl_tx_dis_o <= serdes_intfce_ctrl_tx_dis_int;
-- PRBS Ena
  serdes_intfce_ctrl_prbs_ena_o <= serdes_intfce_ctrl_prbs_ena_int;
-- Test Write Enable
  serdes_intfce_ctrl_tst_wr_ena_o <= serdes_intfce_ctrl_tst_wr_ena_int;
-- PRBS Cnt Rst
  process (clk_sys_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      serdes_intfce_ctrl_cnt_clr_dly0 <= '0';
      serdes_intfce_ctrl_cnt_clr_o <= '0';
    elsif rising_edge(clk_sys_i) then
      serdes_intfce_ctrl_cnt_clr_dly0 <= serdes_intfce_ctrl_cnt_clr_int;
      serdes_intfce_ctrl_cnt_clr_o <= serdes_intfce_ctrl_cnt_clr_int and (not serdes_intfce_ctrl_cnt_clr_dly0);
    end if;
  end process;
  
  
-- Marker Type
  serdes_intfce_ctrl_mkr_type_o <= serdes_intfce_ctrl_mkr_type_int;
-- LED Test
  serdes_intfce_ctrl_led_test_o <= serdes_intfce_ctrl_led_test_int;
-- Clear Faults
  process (clk_sys_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      serdes_intfce_ctrl_clr_faults_dly0 <= '0';
      serdes_intfce_ctrl_clr_faults_o <= '0';
    elsif rising_edge(clk_sys_i) then
      serdes_intfce_ctrl_clr_faults_dly0 <= serdes_intfce_ctrl_clr_faults_int;
      serdes_intfce_ctrl_clr_faults_o <= serdes_intfce_ctrl_clr_faults_int and (not serdes_intfce_ctrl_clr_faults_dly0);
    end if;
  end process;
  
  
-- GTP Reset
  process (clk_sys_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      serdes_intfce_ctrl_gtp_rst_dly0 <= '0';
      serdes_intfce_ctrl_gtp_rst_o <= '0';
    elsif rising_edge(clk_sys_i) then
      serdes_intfce_ctrl_gtp_rst_dly0 <= serdes_intfce_ctrl_gtp_rst_int;
      serdes_intfce_ctrl_gtp_rst_o <= serdes_intfce_ctrl_gtp_rst_int and (not serdes_intfce_ctrl_gtp_rst_dly0);
    end if;
  end process;
  
  
-- Rx Reset
  process (clk_sys_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      serdes_intfce_ctrl_rx_rst_dly0 <= '0';
      serdes_intfce_ctrl_rx_rst_o <= '0';
    elsif rising_edge(clk_sys_i) then
      serdes_intfce_ctrl_rx_rst_dly0 <= serdes_intfce_ctrl_rx_rst_int;
      serdes_intfce_ctrl_rx_rst_o <= serdes_intfce_ctrl_rx_rst_int and (not serdes_intfce_ctrl_rx_rst_dly0);
    end if;
  end process;
  
  
-- Tx Reset
  process (clk_sys_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      serdes_intfce_ctrl_tx_rst_dly0 <= '0';
      serdes_intfce_ctrl_tx_rst_o <= '0';
    elsif rising_edge(clk_sys_i) then
      serdes_intfce_ctrl_tx_rst_dly0 <= serdes_intfce_ctrl_tx_rst_int;
      serdes_intfce_ctrl_tx_rst_o <= serdes_intfce_ctrl_tx_rst_int and (not serdes_intfce_ctrl_tx_rst_dly0);
    end if;
  end process;
  
  
-- CDR Reset
  process (clk_sys_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      serdes_intfce_ctrl_cdr_rst_dly0 <= '0';
      serdes_intfce_ctrl_cdr_rst_o <= '0';
    elsif rising_edge(clk_sys_i) then
      serdes_intfce_ctrl_cdr_rst_dly0 <= serdes_intfce_ctrl_cdr_rst_int;
      serdes_intfce_ctrl_cdr_rst_o <= serdes_intfce_ctrl_cdr_rst_int and (not serdes_intfce_ctrl_cdr_rst_dly0);
    end if;
  end process;
  
  
-- Align Rx
  process (clk_sys_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      serdes_intfce_ctrl_align_dly0 <= '0';
      serdes_intfce_ctrl_align_o <= '0';
    elsif rising_edge(clk_sys_i) then
      serdes_intfce_ctrl_align_dly0 <= serdes_intfce_ctrl_align_int;
      serdes_intfce_ctrl_align_o <= serdes_intfce_ctrl_align_int and (not serdes_intfce_ctrl_align_dly0);
    end if;
  end process;
  
  
-- Rx Buf Reset
  process (clk_sys_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      serdes_intfce_ctrl_rx_buf_rst_dly0 <= '0';
      serdes_intfce_ctrl_rx_buf_rst_o <= '0';
    elsif rising_edge(clk_sys_i) then
      serdes_intfce_ctrl_rx_buf_rst_dly0 <= serdes_intfce_ctrl_rx_buf_rst_int;
      serdes_intfce_ctrl_rx_buf_rst_o <= serdes_intfce_ctrl_rx_buf_rst_int and (not serdes_intfce_ctrl_rx_buf_rst_dly0);
    end if;
  end process;
  
  
-- SFP LOS
-- SFP PRSNT
-- FMC PRSNT
-- Rx Buf Status
-- Rx LOS
-- Rx Clock Corr Cnt
-- Rx Aligned
-- FIFO Full
-- Count
-- Addr
  serdes_intfce_test_mem_addr_o <= serdes_intfce_test_mem_addr_int;
-- Data
-- Data Is K
-- Marker
-- Rate
-- Size
  serdes_intfce_acq_page_size_o <= serdes_intfce_acq_page_size_int;
-- Addr
-- Addr
  rwaddr_reg <= wb_adr_i;
  wb_stall_o <= (not ack_sreg(0)) and (wb_stb_i and wb_cyc_i);
-- ACK signal generation. Just pass the LSB of ACK counter.
  wb_ack_o <= ack_sreg(0);
end syn;
