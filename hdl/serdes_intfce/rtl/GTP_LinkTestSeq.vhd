----------------------------------------------------
----------------------------------------------------
-- THIS FILE WAS GENERATED BY VISUAL ELITE
-- DO NOT HAND-EDIT UNLESS IT'S ABSOLUTELY NECESSARY!
----------------------------------------------------
----------------------------------------------------
-- GNU LESSER GENERAL PUBLIC LICENSE
----------------------------------------------------
-- This source file is free software; you can redistribute it and/or modify it
-- under the terms of the GNU Lesser General Public License as published by the
-- Free Software Foundation; either version 2.1 of the License, or (at your
-- option) any later version. This source is distributed in the hope that it
-- will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-- of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-- See the GNU Lesser General Public License for more details. You should have
-- received a copy of the GNU Lesser General Public License along with this
-- source; if not, download it from http://www.gnu.org/licenses/lgpl-2.1.html
----------------------------------------------------
----------------------------------------------------
--
--  Library Name :  GTP
--  Unit    Name :  GTP_LinkTestSeq
--  Unit    Type :  State Machine
--
------------------------------------------------------

library ieee;
use ieee.STD_LOGIC_1164.all;
use ieee.NUMERIC_STD.all;
library work;
use work.Util.all;
entity GTP_LinkTestSeq is
  generic (
           G_HeaderWords : NATURAL := 22;
           G_DataSeq : NATURAL := 4;
           G_CommaSeq : NATURAL := 1;
           G_DataSize : NATURAL := 3564
           );
  port (
        Clk : in std_logic;
        Rst : in std_logic;
        HeadCount : out std_logic_vector(4 downto 0 );
        LinkData : out std_logic_vector(15 downto 0 );
        LinkStr : out std_logic
        );

end GTP_LinkTestSeq;


architecture GTP_LinkTestSeq of GTP_LinkTestSeq is

  constant C_RecoveryWords : NATURAL := (G_HeaderWords / G_CommaSeq) * G_DataSeq
  ;
  constant B_HCnt : NATURAL := Log2 (G_HeaderWords) - 1;
  constant B_DCnt : NATURAL := Log2 (G_DataSeq) - 1;
  constant B_CCnt : NATURAL := Log2 (G_CommaSeq) - 1;
  constant B_OCnt : NATURAL := Log2 (G_DataSize) - 1;
  signal HCnt : unsigned(B_HCnt downto 0 );
  signal DCnt : unsigned(B_DCnt downto 0 );
  signal OCnt : unsigned(B_OCnt downto 0 );
  signal CCnt : unsigned(B_CCnt downto 0 );
  signal Str : std_logic;

  type visual_TxHead_states is (TxHead, TxD, TxK, TxRec);
  signal visual_TxHead_current : visual_TxHead_states;


begin



  -- Synchronous process
  GTP_LinkTestSeq_TxHead:
  process (Clk)
  begin

    if (rising_edge(Clk)) then
      if (Rst = '1') then
        HCnt <= (others => '1');
        OCnt <= (others => '0');
        CCnt <= (others => '0');
        DCnt <= (others => '0');
        Str <= '0';
        visual_TxHead_current <= TxHead;
      else

        case visual_TxHead_current is
          when TxHead =>
            if (HCnt = G_HeaderWords - 1) then
              OCnt <= (others => '0');
              HCnt <= HCnt + 1;
              Str <= '1';
              visual_TxHead_current <= TxRec;
            else
              HCnt <= HCnt + 1;
              visual_TxHead_current <= TxHead;
            end if;

          when TxD =>
            if (DCnt = G_DataSeq - 1) then
              Str <= '0';
              if (OCnt = G_DataSize - 1) then
                HCnt <= (others => '0');
                visual_TxHead_current <= TxHead;
              else
                CCnt <= (others => '0');
                visual_TxHead_current <= TxK;
              end if;
            else
              DCnt <= DCnt + 1;
              OCnt <= OCnt + 1;
              visual_TxHead_current <= TxD;
            end if;

          when TxK =>
            if (CCnt = G_CommaSeq - 1) then
              DCnt <= (others => '0');
              Str <= '1';
              OCnt <= OCnt + 1;
              visual_TxHead_current <= TxD;
            else
              CCnt <= CCnt + 1;
              visual_TxHead_current <= TxK;
            end if;

          when TxRec =>
            if (OCnt = C_RecoveryWords - 1) then
              CCnt <= (others => '0');
              Str <= '0';
              visual_TxHead_current <= TxK;
            else
              OCnt <= OCnt + 1;
              visual_TxHead_current <= TxRec;
            end if;

          when others =>

            visual_TxHead_current <= TxHead;
        end case;
      end if;
    end if;
  end process GTP_LinkTestSeq_TxHead;

  LinkData <= std_logic_vector(resize(OCnt, 16));
  LinkStr <= Str;
  HeadCount <= std_logic_vector(HCnt);
end GTP_LinkTestSeq;

